<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Results May Vary Terminal</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        :root {
            --bg: #101010;
            --fg: rgb(239, 229, 205);
            --fgBorder: rgba(239,229,205,0.15);
            --secondary: rgb(217, 207, 186);
            --accent: rgba(82, 78, 71, 0.65);
            --green: #7E8B55;
        }
        html, body {
            margin: 0; padding: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: "Quantico", sans-serif;
            font-weight: 400;
            font-style: normal;
        }
        h3 {
            margin-top: 0;
        }
        p > span {
            font-weight: 700;
        }
        #boot {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #container {
            display: none;
            gap: 1em;
            height: 100vh;
            width: 100vw;
        }
        @media screen and (min-width: 651px) {
            #container {
                grid-template-columns: 0.5fr 1fr;
                grid-template-rows: 1fr 1fr;
            }
            #console {
                grid-column-start: 1;
                grid-column-end: 3;
            }
            #console-output {
                max-height: calc(50vh - 4em);
            }
        }
        @media screen and (max-width: 650px) {
            #container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr 1fr;
            }
            #console-output {
                max-height: calc((100vh / 3) - 4em);
            }
        }
        .element {
            padding: 1em;
            border: 2px dashed var(--fgBorder);
        }
        .scrollable {
            overflow-y: scroll;
        }
        #prompt {}
        #console {}
        .cursor {
            height: 1em;
            width: 0.5em;
            background: var(--fg);
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        #prompt-cursor {
            display: none;
        }
        #radar {
            display: flex;
            flex-direction: column;
        }
        #map {
            position: relative;
            height: 100%;
            width: 100%;
        }
        #sweep {
            position: absolute;
            inset: 0;
            z-index: 3;
            transform: translateY(0);
            animation: scan 1.5s alternate infinite linear;
        }
        #map-dot {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 2;
        }
        @keyframes scan {
            100% { transform: translateY(calc(100% - 2em)); }
        }
        #sweep, .sweep-color {
            pointer-events: none;
        }
        .sweep-color {
            width: 100%;
            height: 2em;
            background: linear-gradient(transparent, var(--accent), transparent);
            border-left: 1px solid var(--fg);
            border-right: 1px solid var(--fg);
        }
        #boot-screen {
            width: 100%;
            max-width: 500px;
        }
        #boot-screen > div > p {
            margin: 0;
        }
        .type-child-boot, .type-child-boot > h3 {
            text-align: left;
        }
        .blip {
            position: absolute;
            width: 14px; height: 14px;
            background: var(--fg);
            border-radius: 50%;
            cursor: pointer;
        }
        @keyframes pulse {
            0%   { box-shadow: 0 0 0 0 rgba(239, 229, 205, 0.6); }
            70%  { box-shadow: 0 0 0 12px rgba(239, 229, 205, 0); }
        }
        .blip:hover {
            box-shadow: 0 0 10px var(--fg);
            transform: scale(1.3);
        }
        .uuid {
            position: absolute;
            top: -15px;
            right: -30px;
            font-size: 0.6rem;
            opacity: 0.6;
            pointer-events: none;
        }
        #console-input {
            display: flex;
            flex-direction: row;
        }
        #console-output {
            overflow-y: auto;
        }
        input[type="text"] {
            background: transparent;
            border: none;
            color: var(--fg);
            width: 100%;
            height: 1rem;
            margin-left: 0.5em;
            font-family: "Quantico", sans-serif;
            font-weight: 400;
            font-style: normal;
        }
        input:focus { outline: none; }
    </style>
</head>
<body>
<div id="boot">
    <h3 class="shuffle-boot">RESULTS MAY VARY TERMINAL</h3>
    <div id="boot-screen">
        <div class="type-child-boot">
            <p>INITIALIZING...</p>
            <p>BOOTING RMV OS v4.0.4...</p>
            <p>LOADING TACTICOOL MODULES...</p>
            <p>ESTABLISHING MOSTLY ENCRYPTED LINK...</p>
            <p>CALIBRATING CRT CURVATURE...</p>
            <p>LOADING MAP BLIPS...</p>
            <p>OPERATOR ONLINE...</p>
            <p>Press any key to begin operation</p>
            <div class="cursor"></div>
        </div>
    </div>
</div>
<div id="container">
    <div id="prompt" class="element scrollable">
        <div id="prompt-text">
            <h3 class="shuffle element"># TERMINAL STATUS</h3>
            <div class="type-child">
                <p><span>Connection:</span> Stable</p>
                <p><span>Signal Noise:</span> Moderate</p>
                <p><span>Operator:</span> RsltsMV</p>
            </div>
            <h3 class="shuffle element"># MISSION FEED</h3>
            <div class="type-child">
                <p>[CARNET] Notebook Espionage — top secret scribbles.</p>
                <p>[ARCHUPDATE] Rolling Breakpoint Initiative — proceed with helmet.</p>
                <p>[BLURREDWLP] BLur it out!</p>
                <small>✔ Mission data loaded. Click on a contact to see its data........</small>
            </div>
        </div>
        <div class="cursor" id="prompt-cursor"></div>
    </div>
    <div id="radar" class="element">
        <h3 class="shuffle element"># RMv SCANNER</h3>
        <div id="map">
            <div id="sweep"><div class="sweep-color"></div></div>
            <div id="map-dot"></div>
        </div>
    </div>
    <div id="console" class="element">
        <div id="console-output"></div>
        <div id="console-input">
            <div class="cursor"></div>
            <input type="text" id="term-input" placeholder="Awaiting command...">
        </div>
    </div>
</div>
<script>
  const repos = [
    {
      name: "archupdate",
      url: "https://github.com/bouteillerAlan/archupdate",
      desc: "Rolling Breakpoint Initiative: update Arch, break Arch, repeat."
    },
    {
      name: "carnet",
      url: "https://github.com/results-may-vary-org/carnet",
      desc: "Notebook Espionage: jot things down before they escape."
    },
    {
      name: "docker-companion",
      url: "https://github.com/bouteillerAlan/docker-companion",
      desc: "A docker companion right in your system tray for KDE 6."
    },
    {
      name: "blurredwallpaper",
      url: "https://github.com/bouteillerAlan/blurredwallpaper",
      desc: "Blur & DIM your wallpaper when a window is active for KDE 6."
    },
    {
      name: "earbud-companion",
      url: "https://github.com/bouteillerAlan/earbud-companion",
      desc: "Show your earbuds in a nice way in your system tray for KDE 6."
    },
    {
      name: "dockolor",
      url: "https://github.com/bouteillerAlan/dockolor",
      desc: "Simply colorized the output of docker ps."
    },
    {
      name: "postier",
      url: "https://github.com/bouteillerAlan/postier",
      desc: "Parcel Operations: a postal service toolkit designed for chaotic good."
    },
    {
      name: "grid",
      url: "https://github.com/bouteillerAlan/grid",
      desc: "UI design with grid, now you can dev with it too."
    }

  ];

  const typeChild = document.getElementsByClassName("type-child");
  const typeChildBoot = document.getElementsByClassName("type-child-boot");
  const shuffleChild = document.getElementsByClassName("shuffle");
  const shuffleBoot = document.getElementsByClassName("shuffle-boot");
  const promptCursor = document.getElementById("prompt-cursor");
  const map = document.getElementById("map-dot");
  const termOutput = document.getElementById("console-output");

  function typeText(element, text, rmv = false, speed = 100, callback = null) {
    let i = 0;
    if (rmv) element.textContent = "";
    function type() {
      if (i < text.length) {
        element.textContent += text.charAt(i);
        i++;
        setTimeout(type, speed);
      } else if (callback) {
        callback();
      }
    }
    type();
  }
  function typewriterElements(selector, speed = 30, callback = null) {
    return new Promise((resolve) => {
      const elements = Array.from(selector.children);

      // Masquer tous les enfants au départ
      elements.forEach(el => {
        el.style.visibility = "hidden";
      });

      // Helper: "tape" un texte dans un nœud, et renvoie une Promise
      function typeNodeText(node, fullText) {
        return new Promise((res) => {
          let i = 0;
          node.textContent = "";
          function typeChar() {
            if (i < fullText.length) {
              node.textContent += fullText.charAt(i++);
              setTimeout(typeChar, speed);
            } else {
              res();
            }
          }
          typeChar();
        });
      }

      // Chaîne séquentielle: chaque élément, puis chaque nœud texte
      (async function run() {
        for (const el of elements) {
          el.style.visibility = "visible"; // Afficher la ligne avant d'écrire

          const textNodes = Array.from(el.childNodes).filter(
            node => node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== ""
          );

          for (const node of textNodes) {
            const fullText = node.textContent;
            await typeNodeText(node, fullText);
          }
        }
      })().then(() => {
        if (typeof callback === "function") callback();
        resolve();
      });
    });
  }
  function decryptEffect(element, speed = 40) {
    return new Promise((resolve) => {
      const chars = "!<>-_\\/[]{}—=+*^?#________";
      const text = element.textContent;
      let iterations = 0;

      const interval = setInterval(() => {
        element.textContent = text
          .split('')
          .map((char, i) => {
            if (i < iterations) return text[i];
            return chars[Math.floor(Math.random() * chars.length)];
          })
          .join('');

        if (iterations >= text.length) {
          clearInterval(interval);
          resolve(); // finish promise
        }
        iterations += 1 / 3; // adjust reveal speed
      }, speed);
    });
  }
  function typeToTerminal(lines, speed = 15) {
    let i = 0;
    function typeLine() {
      if (i < lines.length) {
        const line = document.createElement('div');
        termOutput.appendChild(line);
        let j = 0;
        function typeChar() {
          if (j < lines[i].length) {
            line.textContent += lines[i][j];
            j++;
            setTimeout(typeChar, speed);
            termOutput.scrollTop = termOutput.scrollHeight;
          } else {
            i++;
            setTimeout(typeLine, 150);
          }
        }
        typeChar();
      }
    }
    typeLine();
  }

  function startApp() {
    document.getElementById('boot').style.display = 'none';
    document.getElementById('container').style.display = 'grid';
    Array.from(typeChild).forEach((node) => node.style.visibility = "hidden");
    const promises = Array.from(shuffleChild).map((node) => decryptEffect(node));
    Promise.allSettled(promises).then(() => {
      Array.from(typeChild).forEach((node) => {
        typewriterElements(node, 30, () => promptCursor.style.display = "block");
      });
      procDot();
    });
  }
  function procDot() {
    repos.forEach(repo => {
      const blip = document.createElement('div');
      blip.className = 'blip';
      const x = 20 + Math.random() * 60;
      const y = 20 + Math.random() * 60;
      blip.style.left = `${x}%`;
      blip.style.top = `${y}%`;

      const label = document.createElement('div');
      label.className = 'uuid';
      label.textContent = self.crypto.randomUUID().slice(0,6);
      blip.appendChild(label);

      blip.addEventListener('mouseenter', () => {
        codec.style.display = 'block';
        codec.innerHTML = `<strong>${repo.name}</strong><br>${repo.desc}<br><a href="${repo.url}" target="_blank" style="color:var(--fg);text-decoration:underline;">View Repository</a>`;
      });

      blip.addEventListener('mouseleave', () => {
        codec.innerHTML = "Select a mission blip.";
      });

      blip.addEventListener('click', () => {
        blip.style.background = "#7E8B55";
        typeToTerminal([
          `Loading mission data for ${repo.name}...`,
          `Description: ${repo.desc}`,
          `Repository link: ${repo.url}`,
          `Status: READY`,
          `.`
        ]);
      });

      setTimeout(() => {
        map.appendChild(blip);
        blip.style.animation = "pulse 2s infinite";
      }, Math.floor(Math.random() * 1000))
    });
  }

  Array.from(typeChildBoot).forEach((node) => node.style.visibility = "hidden");
  const promises = Array.from(shuffleBoot).map((node) => decryptEffect(node));
  Promise.allSettled(promises).then(() => {
    const typePromises = Array.from(typeChildBoot).map((node) => typewriterElements(node, 30, () => promptCursor.style.display = "block"));
    Promise.allSettled(typePromises).then(() => {
      document.addEventListener('keydown', () => startApp(), { once: true });
      document.addEventListener('touchend', () => startApp(), { once: true });
    })
  });
</script>
</body>
</html>
